1. Object 클래스

:모든 자바 클래스의 최상위 부모 클래스
 - 패키지 : java.lang
 - 자바 컴파일러가 자동으로 상속처리함
 - 자바의 모든 클래스들은 Object 클래스와 동일한 메소드들을 가짐


Object 클래스의 주요 메소드

toString() 메소드 : 객체에 대한 정보를 문자열로 반환
equals () 메소드 : 두 객체를 비교하여 동일한지 판단함

-----------------------------------------------------------------------
2. Wrapper 클래스

: 기본 자료형에 대응하는 클래스
- 패키지 : java.lang
- 클래스의 다양한 메소드 활용 가능

1) 오토 박싱 (auto boxing)
  : 기본 자료형 값을 Wrapper 클래스의 객체로 자동 변환해 주는 것

2) 오토 언박싱 (auto unboxing)
  : Wrapper 클래스의 객체에 있는 값을 기본 자료형으로 자동 변환해 주는 것


Integer 클래스

문자열 숫자 ("123")를 숫자 (123)으로 변환하는 경우

int a = Integer.parseInt("123");


숫자(123)을 문자열 숫자 ("123")로 변환하는 경우

String a = Integer.toString(123);

-----------------------------------------------------------------------
3.

String 클래스

: 문자열 처리를 위한 클래스
- 문자열은 변경이 불가능함
- String 클래스 객체 생성
   - 문자열 상수를 직접 지정하는 방법
   - String 클래스의 생성자 메소드를 이용하는 방법


StringBuffer 클래스

- 버퍼 메모리를 확보해 놓고 문자열을 처리
- String 클래스보다 처리 속도가 빠름
- 문자열을 수정 및 변경할 수 있어서 다양한 문자열 처리가 가능함


Random 클래스

- 임의의 값을 발생시키는 클래스
- 객체 생성 후 여러 번 임의의 값을 가져올 수 있음
- 패키지 : java.util


Math 클래스

- 수학과 관련된 메소드를 제공하는 클래스
- 대부분 정적 멤버 메소드로 정의되어 있음


Calendar 클래스

- 날짜와 시간을 표현하는 클래스
- 시스템의 날짜와 시간을 가져오기 위해서 getInstance() 메소드로 객체를 생성
- 패키지 : java.util

-----------------------------------------------------------------------
4. 자료 구조

- 배열 (array)
- 스택 (stack)
- 큐 (queue)
- 링크드리스트 (Linkedlist)
- 트리 (Tree)
- 해쉬 (Hash)

-----------------------------------------------------------------------
5. 컬렉션 프레임워크

: 자료구조를 효율적으로 사용하고, 일관성 있게 접근하기 위한 틀

1) Collection 인터페이스 
: 자료구조의 추가, 수정, 삭제, 검색을 위한 인터페이스

- 컬렉션 프레임워크의 최상위 인터페이스
- 객체를 추가, 삭제, 검색 등을 할 수 있는 일반적인 자료구조의 기능을 정의


2) Collection 클래스
: 컬렉션 인터페이스를 구현한 클래스

패키지: java.util  (컬렉션 인터페이스와 컬렉션 클래스들은 java.util 패키지에 존재)

-----------------------------------------------------------------------
5-1. List 컬렉션 활용

List 인터페이스

- Collection 인터페이스의 하위 인터페이스로, 컬렉션 인터페이스의 모든 메소드를 상속함
- 객체의 추가, 삭제, 검색, 수정이 가능
- 순서가 있는 자료 구조로 배열과 같이 인덱스로 관리함
- 동일한 객체의 중복 저장이 가능함
- List 인터페이스를 구현한 컬렉션 클래스로는 ArrayList, LinkedList, Vector, Stack 이 있음

-----------------------------------------------------------------------
ArrayList 클래스

: List 인터페이스를 구현한 대표적인 컬렉션 클래스

- ArrayList에 객체를 생성하는 방법

   1. 모든 종류의 객체를 저장할 수 있는 자료 구조 

	ArrayList list = new ArrayList();       // ArrayList 클래스의 객체를 생성하거나
	List list = new ArrayList();		// ArrayList 클래스가 구현한 List 인터페이스 참조 변수로 ArrayList 클래스의 객체를 참조하도록 함

   2. 한 종류의 객체만 저장할 수 있는 자료 구조

	1) 제네릭 문법을 사용하여 클래스의 객체 생성시, 컬렉션에 저장이 가능한 클래스를 지정해주면 된다

	 * String 클래스의 객체만 저장할 수 있도록 ArrayList 클래스의 객체를 생성하는 예시 (제네릭 문법)

	  ArrayList<String> list = new ArrayList<String>();
	  List<String> list = new ArrayList<String>();

	2) 정해진 자료형만 저장 가능한 컬렉션을 생성할 때, <> 사이에 동일한 자료형을 지정해 주어야 함

	 * 잘못된 예

 	 - List<String> list = new ArrayList<Character>();

    3. ArrayList 클래스의 올바른 객체 생성 예시

	- ArrayList list = new ArrayList();
	- List list = new ArrayList();
	- ArrayList<String> list = new ArrayList<String>();

-----------------------------------------------------------------------	
LinkedList 클래스

: List 인터페이스와 Queue 인터페이스를 구현

- LinkedList 자료 구조
   
  1) 인접한 노드와의 참조 링크를 이용한 체인과 같은 구조
   2)  ArrayList 클래스와 동일하게 사용

- Queue 자료 구조

  1) FIFO(First In First Out) 구조: 선입선출 

-----------------------------------------------------------------------
Stack 클래스

: Vector 클래스의 하위 클래스

- Stack 자료 구조

   1) LIFO(Last In First Out) 구조 : 후입선출 
-----------------------------------------------------------------------
5-2. 반복자 인터페이스 

: 컬렉션에 저장된 객체를 순차적으로 접근하기 위한 인터페이스

    - 모든 컬렉션 클래스에 구현되어 있기 때문에, 자료구조에 접근하는 방식이 통일되어 있음

       <종류>
	
	 1. Enumeration
를 개선한 2. Iterator
을 상속한 3. ListIterator  (List 인터페이스를 구현한 클래스만 사용 가능)


       <반복자 인터페이스의 주요 메소드>

	인터페이스 		주요 메소드 		 	설명

	Enumeration 	  boolean hasMoreElements()     컬렉션에서 읽어올 다음 객체가 있는지 여부
			  E nextElement()	        다음 객체를 반환

	Iterator	  boolean hasNext()		컬렉션에서 읽어올 다음 객체가 있는지 여부
			  E next()			다음 객체를 반환	
			  void remove()			객체 삭제	

		   
	ListIterator 	  boolean hasNext()		컬렉션에서 읽어올 다음 객체가 있는지 여부
			  E next()			다음 객체를 반환
			  void remove()			객체 삭제
			  void add(E e)			객체 추가
			  void set(E e)			객체 변경
			   boolean hasPrevious()		컬렉션에 읽어올 이전 객체가 있는지 여부
			   E previous()			이전 객체를 반환

-----------------------------------------------------------------------
5-3. Set 인터페이스

- Collection 인터페이스의 하위 인터페이스로,  Collection 인터페이스의 모든 메소드를 상속함
- 객체의 추가, 삭제, 검색, 수정이 가능
- 순서가 없는 자료구조
- 동일한 객체의 중복 저장 불가
- 주요 메소드: List 컬렉션과 동일


1) HashSet 클래스
: Set 인터페이스를 구현한 컬렉션 클래스 

-----------------------------------------------------------------------
Map 인터페이스

- 키(key)와 값(value)의 쌍으로 이루어진 구조를 정의
- 순서가 없는 자료구조
- 키(key) 중복 불가
- 값(value)은 중복 가능

!! 키는 중복 저장 불가, 값은 중복 저장 가능 !!


1) HashMap 클래스
: Map 인터페이스를 구현한 컬렉션 클래스

- HashMap 클래스의 주요 메소드
	
   put(키,값)  		-> 키와 값의 쌍을 저장
   get(키)    		-> 값을 반환
  remove(키)  		-> 해당 키, 값을 삭제
  containsKey(키)  	-> 해당 키가 있는지 여부
   containsValue(값)	-> 해당 값이 있는지 여부  

   Set<K> keyset()
	
  -> keyset() 메소드로 Hash 테이블에 있는 키 값들을 Set 인터페이스 참조 변수로 반환받아서 
        반복자를 이용하여 순차적으로도 접근할 수 있음 

-----------------------------------------------------------------------
6. 제네릭

- 클래스나 메소드에서 처리할 자료형을 미리 지정하지 않음
- 클래스의 객체를 생성할 때 자료형을 지정함
- 주로 컬렉션 클래스와 인터페이스 및 반복자 클래스에 사용됨


 

-----------------------------------------------------------------------
7. 확장 for문

- 배열 또는 컬렉션을 위한 for문
- 배열의 인덱스나 컬렉션의 반복자 없이도 반복 가능

for ( 변수 : 배열 또는 컬렉션) {
    반복코드 
}


변수 -> 배열이나 컬렉션의 요소들이 반복할 때 마다 순차적으로 지정됨
: -> 구분자 
배열 또는 컬렉션 -> 반복할 배열이나 컬렉션
-----------------------------------------------------------------------
8. 열거형 (enumeration type)

- 상수들을 묶어서 정의한 자료형
- 열거형 변수는 정의된 상수들만 지정할 수 있음



-----------------------------------------------------------------------
9. 멀티 스레드

1) 프로세스

- 실행중인 프로그램을 말함
- 하나의 프로세스는 한 개 이상의 스레드로 동작됨

2) 스레드 (thread)

- 실제로 작업을 수행하는 단위 
- 싱글 스레드 : 프로세스가 하나의 스레드로 동작하는 것 
- 멀티 스레드 : 프로세스가 동시에 두 개 이상의 스레드로 동작하는 것

-----------------------------------------------------------------------
2-1) 멀티 스레드 클래스 구현하는 방법

# Thread 클래스를 상속받는 방법

   1. Thread 클래스를 상속
   2. run() 메소드 오버라이딩

       -> class ThreadA extends Thread {
	  public void run() {
	
       }
    }

   3. Thread를 상속받은 클래스의 객체를 생성

       -> ThreadA ta = new ThreadA();
        ta.start();

   4. start() 메소드를 호출
       -> start 메소드로 스레드를 시작함. start 메소드를 호출하면 run 메소드가 호출되어 
            스레드가 실행되는데, run 메소드의 내부가 스레드 실행 블럭이 됨


# Runnable 인터페이스를 구현하는 방법

   1. Runnable 인터페이스를 구현 
   2. run() 메소드 오버라이딩

     -> public class ThreadA implements Runnable {
	
	public  void run() {
	
	}
     }

   3. Runnable 인터페이스를 구현한 클래스의 객체를 생성
   4. Runnable 구현 클래스의 객체를 이용하여 Thread 클래스의 객체 생성
     5. start() 메소드 호출

     -> Runnable ra = new ThreadA();
        Thread ta = new Thread(ra);
        ta.start();
-----------------------------------------------------------------------
2-2) 멀티 스레드 제어

[스레드 지연]

- sleep() : 일정 시간 동안 스레드의 실행을 멈춤
- join()    : 해당 스레드의 동작이 종료될 때 까지 실행을 멈춤 

-> 두 메소드 모두  try ~ catch 블록 내부에서만 사용 가능


1. 일정 시간 스레드를 멈춤 

try { 
    Thread.sleep(3000);   // 3초
} catch(Exception e) {}


2. 해당 스레드가 종료될 때까지 실행 멈춤

Thread t = new Thread();    // 스레드 객체 생성 
t.start();                  // 시작 

try {
  t.join();		    // 스레드 실행 종료까지 실행 멈춤 
} catch(Exception e) {}


[스레드 양보]

- 스레드에게 주어진 실행시간을 다음 차례의 스레드에게 양보 
- 하나의 스레드가 독점적으로 실행되지 않도록 함
- Thread.yield() 메소드 호출 


-----------------------------------------------------------------------
2-3) 동기화 (synchronization)

- 여러 개의 스레드가 하나의 자원을 사용할 때 필요
- 하나의 스레드가 자원을 사용한 다음, 다른 스레드가 자원을 사용
- 하나의 스레드가 작업중인 것을 다른 스레드가 간섭하지 못하도록 함

동기화 방법
1. synchronized 키워드를 사용
2. 메소드에 지정하거나 특정한 영역을 지정

동기화 제어

- wait() : 동기화 영역에서 스레드의 실행을 일시 정지시킴
- notify() : 일시 정지된 스레드를 다시 실행하도록 함


-----------------------------------------------------------------------

10. 예외 (exception)

- 정상적인 프로그램 실행 과정에서 발생할 수 있는 에러
- 예외를 프로그램에서 처리하면 프로그램의 안전성이 높아지고 견고해짐

1) 대표적인 예외 발생 사례

- 파일을 읽어야 하는데 파일이 없는 경우
- 네트워크 응답이 없는 경우

-> 주로 입출력과 관계되어 발생됨


2 ) 예외를 처리하기 위한 클래스

- Throwable 클래스를 상속 받은 Exception 클래스가 최상위 클래스
- 예외 클래스 이름 : xxxException


3) 예외 발생 및 처리 순서

- 프로그램 실행 중 예외가 발생
- JVM (자바가상머신)이 해당 예외에 대한 xxxException 클래스의 객체를 생성하여 프로그램에 던짐
- 프로그램에선  xxxException 클래스의 객체를 받아서 처리하게 됨


try {
   Thread.sleep(1000);     // try 블록 내부에 예외가 발생되는 메소드를 사용
} catch(xxxException e) {
   e.printStackTrace();    // catch 블록 내부에서 예외를 처리하면 된다 
}

-----------------------------------------------------------------------

4) 예외 처리 문법

1. try ~ catch ~ finally 문

try  {
   // try 블록 : 예외가 발생할 가능성이 있는 코드 사용 
}
catch (xxxException e) {
  // catch 블록 : 예외 처리. try블록 내부에서 여러 종류의 예외가 발생되는 경우 여러 개 사용 가능 
}
catch (xxxException e) {

}
finally {
  // finally 블록 : 예외 발생 여부와 상관없이 실행, 생략해도 됨
}


2. throws 문

(1) 예외를 던지는 명령문

(2) throws문이 정의된 메소드는 예외를 발생시키기 때문에 
      반드시 try ~ catch ~ finally 문을 사용하여 예외를 처리해줘야 함 

(3) throws문 사용하기
     -> 예외를 처리하지 않고 던지기 

  // 1 - test 메소드

	void test() throws InterruptedException {	// test() 정의 부분에 throws 명령문을 이용하여 예외를 던짐  
	   Thread.sleep(1000);				// 예외처리 하지 않음
	}

 // 2 - test 메소드를 사용하는 부분에서 try ~ catch ~ finally 문을 이용하여 예외를 처리할 수 있게 됨 

	try {
	    test();             // 위의 예외처리
	}
	catch (InterruptedException e) {
	    e.printStackTrace(); 
	}


3. (예외가 발생되었을 경우) 예외 정보 출력하기 

- printStackTrace() : 예외 발생 메소드의 정보와 위치, 원인을 화면에 출력
- getMessage() : 예외 발생 원인을 문자열로 반환


try {
  Thread.sleep(1000);
}
catch(InterruptedException e) {
  e.printStackTrace();
  System.out.println(e.getMessage());
}

-----------------------------------------------------------------------

11. 입출력 스트림 (stream)

: 데이터의 흐름을 시냇물처럼 물 흐르듯이 처리하는 것

입력 - 키보드, 파일, 네트워크, 데이터베이스 등
출력 - 모니터, 파일, 네트워크, 데이터베이스 등


1) 입출력 스트림의 종류

- 바이트 입출력 스트림 : 바이트(byte) 단위로 입출력 하는 스트림
- 문자 입출력 스트림 : 문자 단위로 입출력 하는 스트림


2) 입출력 스트림 클래스

- 패키지 : java.io
- 입력용과 출력용 클래스로 나누어져 있음 


3) 입출력 스트림 클래스 종류

1. 바이트 입출력 스트림 클래스

- InputStream (입력용 스트림 클래스)
- OutputStream (출력용 스트림 클래스) 

2. 문자 입출력 스트림 클래스 

- Reader (입력용 스트림 클래스)
- Writer (출력용 스트림 클래스) 

-----------------------------------------------------------------------

1)  InputStream/ OutputStream  (바이트 입출력 스트림 클래스)

(1) 표준 입출력 스트림

- 표준 입력 : System 클래스의 in 멤버변수  (필드)
- 표준 출력 : System 클래스의 out 멤버변수 (필드)

(2) 주요 메소드

- inputStream 클래스의 주요 메소드 

  -> int read()	: 1바이트를 읽어서 반환. 반환값이 -1이면 파일 끝 
  -> int read(byte[] b) : b 배열에 읽은 데이터가 저장되며, 총 읽은 바이트 수를 반환함
   -> void close()  : 입력 스트림 닫기 

- OutputStream 클래스의 주요 메소드

  -> void write(int b) : 1바이트 출력
   -> void write(byte[] b) : b 배열의 값을 출력 (바이트 배열을 출력하는_ ) 
   ->  void close() : 출력 스트림 닫기  

-----------------------------------------------------------------------

2)  FileInputStream/ FileOutputStream (바이트 입출력 스트림 클래스)

- File 클래스 : 파일을 접근하기 위한 클래스
- File 클래스의 객체를 이용하여 스트림 객체를 생성함
-  InputStream과 OutputStream의 하위 클래스이므로 주요 메소드는 동일함


3)  BufferedInputStream/ BufferedOutputStream  (바이트 입출력 스트림 클래스)

- 버퍼가 있는 입출력 스트림 


4) DataInputStream/ DataOutputStream (바이트 입출력 스트림 클래스)

- 기본 자료형을 입출력 할 수 있는 스트림 
- 기본 자료형 각각에 맞는 readXXX() 메소드와 writeXXX() 메소드가 존재함 


5) ObjectInputStream/ ObjectOutputStream

- 객체 직렬화가 가능한 클래스의 객체를 입출력 할 수 있는 스트림

6) PrintStream

- 텍스트를 기반으로 출력하는 스트림 클래스

-----------------------------------------------------------------------

12. 
