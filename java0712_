//1
package sec01.exam06;

public class Car {

	public int speed;

	public void speedUp() {
		// 오버라이딩 가능
		speed += 1;
	}

	public final void stop() {
		// final 메소드는 메소드 오버라이딩이 안됨
		System.out.println("차를 멈춤");
		speed = 0;
	}

}
//2
package sec01.exam06;

public class SportsCar extends Car {

	@Override
	public void speedUp() {
		speed += 10;
	}
	
//	@Override
//	public void stop(){   //final 메소드는 오버라이딩 불가능
//		System.out.println("스포츠카를 멈춤");
//		speed =0;
//	}
	
	public void stop(int x) {
		// 리턴값이나 매개변수!를 변경하면 메소드 오버라이드 아님! 아예 다른 것
		System.out.println("스포츠카를 멈춤");
		speed = 0;
	}
	
}
-------------------------------------------------------------------------------------
//3  A
package sec01.exam07.pack1;

public class A {

	// protected 멤버필드
	protected String field;

	protected A() {// protected 생성자

	}

	protected void method() { // protected 메소드

	}
}

//4 B
package sec01.exam07.pack1;

public class B {
	// A와 B는 같은 패키지 
	public void method() {
		// protected는 같은 패키지에서는 자유롭게 접근 가능함!!
		A a = new A();
		a.field = "value";
		a.method();
	}
}

//5 C
package sec01.exam07.pack2;

import sec01.exam07.pack1.A;

public class C {
//	에러
	
//	public void method() {
//		//protected는 다른 패키지에서는 접근 불가능함
//		A a = new A;
//		a.field = "value";
//		a.method();
//	}
}

//6 D
package sec01.exam07.pack2;

import sec01.exam07.pack1.A;

public class D extends A {
	
	String a;
	String b;
	
	public D(String a, String b) {  // 다른 패키지라도 상속받은 자식 클래스는 접근됨
		
		super();
		this.field = "value";
		this.method();

		this.a = a;
		this.b = b;
	}
}
-------------------------------------------------------------------------------------
//7 부모
package sec01.verify.exam04;

public class Parent {
	
	public String name;

	// 부모 클래스의 생성자를 별도로 만들었음. (디폴트 생성자는 별도로 안 만들어짐)
	public Parent(String name) {
		
		this.name = name;
	}
	
	
}

//8 자식
package sec01.verify.exam04;

public class Child extends Parent{
	
	private int studentNo;
	
	public Child(String name, int studentNo) { 
		
		//this.name = name; // 에러, 아래처럼 수정하면 된다
		super(name);
		this.studentNo = studentNo;
	}
}
-------------------------------------------------------------------------------------
// 9 부모

package sec01.verify.exam04;
// 부모
public class Parent {	
	public String nation;
	
	public Parent() {
		this("대한민국");
		System.out.println("Parent() call");
	}
	
	public Parent(String nation) {
		this.nation = nation;
		System.out.println("Parent(String nation) call");
	}	
}

//10 자식

package sec01.verify.exam04;
// 자식
public class Child extends Parent{
	private String name;
	
	public Child() {
		this("홍길동");
		System.out.println("Child() call");
	}
	
	public Child(String name) {
		this.name = name;
		System.out.println("Child(String name) call");
	}
}

//11 실행 

package sec01.verify.exam04;
// 자식 실행
public class ChildExample {

	public static void main(String[] args) {
		
		Child child = new Child();

		
		// 출력결과
		//Parent(String nation) call
		//Parent() call
		//Child(String name) call
		//Child() call

	}

}
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
연습
// 12 부모

package _02;
// 부모 클래스
public class P {

	// 인자가 없는 생성자
	P() {
		System.out.println("A");
	}
	
	// 인자(파라미터) 있는 생성자
	P(int a) {
		System.out.println("B");
	}
	
}

// 13 자식

package _02;
// 자식 클래스
public class C extends P{
	
	// !! 부모를 명시적으로 호출하고 있는지 꼭 확인!!
	
	// 부모의 생성자를 명시적으로 호출하지 않을 때는
	// 부모가 갖고 있는 디폴트(인자 없는) 생성자를 묵시적으로 호출
	
	// 부모가 갖고있는 생성자 먼저 출력하고 본인 출력
	
	C () { 
		System.out.println("C");
	}
	// 출력: A -> C
	
	// 이것도 동일
	// D를 출력하기 전에 부모 먼저 호출
	C (int a) {
		System.out.println("D");
	}
	// 출력: A -> D
	
	// super을 사용해서 부모(P)를 명시적으로 호출하고있음
	// int a 인자 하나를 넘겼기때문에 
	// 부모가 갖고있는 인자 있는 생성자 P (int a)를 호출하고
	// 다시 돌아와서 본인 출력
	C (int a, int b) {
		super(a);
		System.out.println("E");
	}
	// 출력: B -> E
}

// 14 실행

package _02;
// 실행
public class C_Example {

	public static void main(String[] args) {
		
		// 1번
		P p1 = new C();  
		//p1이라는 인스턴스는 부모(P) 형태로 날 낳은것
		//상속 관계에서는 부모(P)부터 출력하고 돌아와서 본인 출력
		
		// 2번
		P p2 = new C(1);
		
		// 3번
		P p3 = new C(1,2);
		
		
		// 출력결과
		//A
		//C
		//A
		//D
		//B
		//E

	}

}
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
// 15 
package sec01.exam06;

public class Car {

	public int speed;

	public void speedUp() {
		// 오버라이딩 가능
		speed += 1;
	}

	public final void stop() {
		// final 메소드는 메소드 오버라이딩이 안됨
		System.out.println("차를 멈춤");
		speed = 0;
	}

}

//16
package sec01.exam06;

public class SportsCar extends Car {

	@Override
	public void speedUp() {
		speed += 10;
	}
	
//	@Override
//	public void stop(){   //final 메소드는 오버라이딩 불가능
//		System.out.println("스포츠카를 멈춤");
//		speed =0;
//	}
	
	public void stop(int x) {
		// 리턴값이나 매개변수!를 변경하면 메소드 오버라이드 아님! 아예 다른 것
		System.out.println("스포츠카를 멈춤");
		speed = 0;
	}
	
}
-------------------------------------------------------------------------------------
//17 부모
package sec02.exam01;
// 최상위 객체
public class Car {
	
	//멤버필드 4개
	// 디폴트 -> 같은 패키지 안에서만 가능
	String color;   // 자동차 색상
	String company; // 제조 회사
	int speed;  	// 속도
	int cost;  		// 가격
	
	
	// 생성자!! 만들기 -> 우클릭
	// 생성자를 따로 만들게되면 기본 생성자는 만들어지지 않는다
	
	// 매개변수 2개인 생성자
	public Car(String color, String company) {
		this.color = color;
		this.company = company;
	}
	
	// 메소드!!
	
	// int 타입을 받는 매개변수 1개짜리 메소드, void 사용했기 때문에 리턴타입은 없음
	// 매개변수의 숫자만큼 스피드 증가
	void speedUp(int speed) {		
		this.speed += speed;
		// 또는 speed += x; 로 표현 가능하나 this 사용을 권장
	}
	
	// int 타입을 받는 매개변수 1개짜리 메소드, void 사용했기 때문에 리턴타입은 없음
	// 매개변수의 숫자만큼 스피드 감소
	void speedDown(int speed) {		
		this.speed -= speed;
		// 또는 speed -= x; 로 표현 가능하나 this 사용을 권장
	}
	

	// 매개변수 없고, 리턴타입 없음
	void start() {
		System.out.println("시동을 걸었습니다.");
	}
	
	// 매개변수 없고, 리턴타입 없음
	void stop() {
		System.out.println("차를 멈춥니다.");
	}
	
}
-------------------------------------------------------------------------------------
//18

